import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as t,o as r}from"./app-CXIHmgjU.js";const o="/assets/images/notes/java/jvm/garbageCollectorScenario.jpg",n={};function i(c,e){return r(),l("div",null,e[0]||(e[0]=[t('<h1 id="java-中经典垃圾回收器" tabindex="-1"><a class="header-anchor" href="#java-中经典垃圾回收器"><span>Java 中经典垃圾回收器</span></a></h1><p>垃圾收集器是内存管理工具，也就是垃圾回收的具体实现。</p><figure><img src="'+o+'" alt="HotSpot 虚拟机的垃圾收集器" tabindex="0" loading="lazy"><figcaption>HotSpot 虚拟机的垃圾收集器</figcaption></figure><blockquote><p>图上是七种不同分代的收集器，如果两个收集器之间存在连线，就说明它们之间可以搭配使用，图中收集器所处的区域，则表示它是新生代收集器还是老年代收集器。</p></blockquote><h2 id="简单概念" tabindex="-1"><a class="header-anchor" href="#简单概念"><span>简单概念</span></a></h2><h3 id="并行和并发" tabindex="-1"><a class="header-anchor" href="#并行和并发"><span>并行和并发</span></a></h3><blockquote><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</p></blockquote><h3 id="吞吐量-throughput" tabindex="-1"><a class="header-anchor" href="#吞吐量-throughput"><span>吞吐量（Throughput）</span></a></h3><blockquote><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。 假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></blockquote><h3 id="gc-类型" tabindex="-1"><a class="header-anchor" href="#gc-类型"><span>GC 类型</span></a></h3><h4 id="部分收集-partial-gc" tabindex="-1"><a class="header-anchor" href="#部分收集-partial-gc"><span>部分收集 (Partial GC)</span></a></h4><p>Partial GC 指的是目标不是完整收集整个 Java 堆的垃圾收集，其中又分为</p><ul><li>新生代收集 (Minor GC/Young GC)：指目标只是新生代的垃圾收集。</li><li>老年代收集 (Major GC/Old GC)：指目标只是老年代的垃圾收集。 <blockquote><p>目前只有 CMS 收集器会有单独收集老年代的行为。(Major GC 说法有点混淆，需要根据上下文区分到底是指老年代收集还是整堆收集。)</p></blockquote></li><li>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。 <blockquote><p>目前只有 G1 收集器会有这种行为</p></blockquote></li></ul><h4 id="整堆收集-full-gc" tabindex="-1"><a class="header-anchor" href="#整堆收集-full-gc"><span>整堆收集 (Full GC)</span></a></h4><p>收集整个 Java 堆和方法区的垃圾收集。</p><h2 id="serial-收集器" tabindex="-1"><a class="header-anchor" href="#serial-收集器"><span>Serial 收集器</span></a></h2><p>Serial 垃圾收集器是最基本的垃圾收集器，它是单线程的收集器。单线程的意思是，它进行垃圾回收时必须暂停其他所有的工作线程，直到它收集结束。 在服务器环境中使用它体验感很不好，想一下用户访问网站。。结果垃圾收集一下暂停一下。。。。 但它是虚拟机运行在Client模式下的默认新生代收集器，因为桌面应用新生代内存不会太大，停顿时间可以控制一百毫秒以内，只要不是频繁发生，还是可以接受的。</p><h2 id="serial-old-收集器" tabindex="-1"><a class="header-anchor" href="#serial-old-收集器"><span>Serial Old 收集器</span></a></h2><p>Serial Old 是 Serial 的老年代版本。它也是单线程收集器。使用标记整理算法。主要也是给Client 模式下的虚拟机使用。</p><h2 id="parnew-收集器" tabindex="-1"><a class="header-anchor" href="#parnew-收集器"><span>ParNew 收集器</span></a></h2><p>ParNew 收集器是 Serial 收集器的多线程版本，其他与Serial 收集器没有什么太大的区别。它是Server模式下的虚拟机中首选的新生代收集器。</p><h2 id="parallel-scavenge-收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge-收集器"><span>Parallel Scavenge 收集器</span></a></h2><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，也是并行的多线程收集器。 Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量。 吞吐量=运行代码时间/(运行代码时间+垃圾收集时间）</p><h2 id="parallel-old-收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old-收集器"><span>Parallel Old 收集器</span></a></h2><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理算法。</p><h2 id="cms-concurrent-mark-sweep-收集器" tabindex="-1"><a class="header-anchor" href="#cms-concurrent-mark-sweep-收集器"><span>CMS(Concurrent Mark Sweep)收集器</span></a></h2><p>CMS 是一种以获得最短回收停顿时间为目标的收集器。CMS是基于标记清除算法来实现的。</p><h2 id="g1-garbage-first-收集器" tabindex="-1"><a class="header-anchor" href="#g1-garbage-first-收集器"><span>G1(Garbage-First)收集器</span></a></h2><p>G1是一款面向服务端应用的垃圾收集器。 G1 将整个java堆划分为多个大小相等的独立区域，有计划的避免进行全区域的垃圾回收。G1跟踪各个区域的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需要时间的经验值)，维护 一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。</p><h1 id="相关资料" tabindex="-1"><a class="header-anchor" href="#相关资料"><span>相关资料</span></a></h1><p><a href="https://book.douban.com/subject/6522893/" target="_blank" rel="noopener noreferrer">深入理解 Java 虚拟机-周志明</a></p>',31)]))}const h=a(n,[["render",i],["__file","jvm-gc-garbage-collector.html.vue"]]),d=JSON.parse('{"path":"/notes/dev/java/jvm/jvm-gc-garbage-collector.html","title":"Java 中经典垃圾回收器(Garbage Collector)","lang":"zh-CN","frontmatter":{"title":"Java 中经典垃圾回收器(Garbage Collector)","date":"2024-11-24T22:50:00.000Z","category":["笔记"],"tag":["Java","JVM","后端开发备忘录"],"description":"记录一些Java 中经典垃圾回收器，以备查看。","head":[["meta",{"property":"og:url","content":"https://yeluozhiqiu.site/notes/dev/java/jvm/jvm-gc-garbage-collector.html"}],["meta",{"property":"og:site_name","content":"叶落知秋"}],["meta",{"property":"og:title","content":"Java 中经典垃圾回收器(Garbage Collector)"}],["meta",{"property":"og:description","content":"记录一些Java 中经典垃圾回收器，以备查看。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yeluozhiqiu.site/assets/images/notes/java/jvm/garbageCollectorScenario.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-04T15:11:55.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:tag","content":"后端开发备忘录"}],["meta",{"property":"article:published_time","content":"2024-11-24T22:50:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-04T15:11:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 中经典垃圾回收器(Garbage Collector)\\",\\"image\\":[\\"https://yeluozhiqiu.site/assets/images/notes/java/jvm/garbageCollectorScenario.jpg\\"],\\"datePublished\\":\\"2024-11-24T22:50:00.000Z\\",\\"dateModified\\":\\"2024-12-04T15:11:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"叶子\\",\\"url\\":\\"https://yeluozhiqiu.site\\",\\"email\\":\\"caoofangqi@outlook.com\\"}]}"]]},"headers":[{"level":2,"title":"简单概念","slug":"简单概念","link":"#简单概念","children":[{"level":3,"title":"并行和并发","slug":"并行和并发","link":"#并行和并发","children":[]},{"level":3,"title":"吞吐量（Throughput）","slug":"吞吐量-throughput","link":"#吞吐量-throughput","children":[]},{"level":3,"title":"GC 类型","slug":"gc-类型","link":"#gc-类型","children":[]}]},{"level":2,"title":"Serial 收集器","slug":"serial-收集器","link":"#serial-收集器","children":[]},{"level":2,"title":"Serial Old 收集器","slug":"serial-old-收集器","link":"#serial-old-收集器","children":[]},{"level":2,"title":"ParNew 收集器","slug":"parnew-收集器","link":"#parnew-收集器","children":[]},{"level":2,"title":"Parallel Scavenge 收集器","slug":"parallel-scavenge-收集器","link":"#parallel-scavenge-收集器","children":[]},{"level":2,"title":"Parallel Old 收集器","slug":"parallel-old-收集器","link":"#parallel-old-收集器","children":[]},{"level":2,"title":"CMS(Concurrent Mark Sweep)收集器","slug":"cms-concurrent-mark-sweep-收集器","link":"#cms-concurrent-mark-sweep-收集器","children":[]},{"level":2,"title":"G1(Garbage-First)收集器","slug":"g1-garbage-first-收集器","link":"#g1-garbage-first-收集器","children":[]}],"git":{"createdTime":1732461369000,"updatedTime":1733325115000,"contributors":[{"name":"叶子","email":"caofangqi@outlook.com","commits":1}]},"readingTime":{"minutes":3.72,"words":1117},"filePathRelative":"notes/dev/java/jvm/jvm-gc-garbage-collector.md","localizedDate":"2024年11月24日","excerpt":""}');export{h as comp,d as data};
